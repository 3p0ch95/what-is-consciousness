<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An Essay on Consciousness by Jesse Pardue</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Merriweather:ital,wght@0,300;0,400;0,700;1,300;1,400&display=swap');
        
        body {
            font-family: 'Merriweather', serif;
            background-color: #f9fafb;
            color: #1f2937;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Inter', sans-serif;
        }
        .canvas-container {
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 0.5rem;
            overflow: hidden;
            position: relative;
            margin: 2rem 0;
            transition: all 0.5s ease;
        }
        .interactive-label {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 0.75rem;
            pointer-events: none;
        }
        /* Custom scrollbar for webkit */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #888; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555; 
        }
        .prose-custom p {
            margin-bottom: 1.5em;
            line-height: 1.8;
            font-size: 1.125rem;
        }
        .error-message {
            color: #ef4444;
            background: #fee2e2;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #f87171;
            margin: 1rem 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Error Boundary Component ---
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }

            componentDidCatch(error, errorInfo) {
                console.error("React Error:", error, errorInfo);
            }

            render() {
                if (this.state.hasError) {
                    return (
                        <div className="p-8 text-center">
                            <h2 className="text-2xl font-bold text-red-600 mb-4">Something went wrong</h2>
                            <p className="mb-4">The application encountered an error.</p>
                            <pre className="error-message text-left overflow-auto">
                                {this.state.error && this.state.error.toString()}
                            </pre>
                            <button 
                                onClick={() => window.location.reload()}
                                className="px-4 py-2 bg-gray-800 text-white rounded hover:bg-gray-700"
                            >
                                Reload Page
                            </button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- 3D Helper Components ---
        const ThreeScene = ({ initScene, animateScene, cleanupScene, dependencies = [] }) => {
            const containerRef = useRef(null);
            const requestRef = useRef(null);
            const rendererRef = useRef(null);
            const sceneInfoRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current) return;
                if (typeof THREE === 'undefined') return;

                const width = containerRef.current.clientWidth;
                const height = containerRef.current.clientHeight;

                const scene = new THREE.Scene();
                // Add explicit fog to blend edges for 'loop' feel in some scenes, mostly subtle
                scene.fog = new THREE.FogExp2(0x000000, 0.02);

                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                containerRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 1);
                pointLight.position.set(10, 10, 10);
                scene.add(pointLight);

                let userObjects = {};
                try {
                    userObjects = initScene(scene, camera, renderer);
                } catch (err) {
                    console.error("Error initializing scene:", err);
                }
                sceneInfoRef.current = { scene, camera, renderer, userObjects };

                const animate = (time) => {
                    requestRef.current = requestAnimationFrame(animate);
                    if (animateScene && sceneInfoRef.current) {
                        try {
                            animateScene(sceneInfoRef.current, time);
                        } catch (err) { }
                    }
                    renderer.render(scene, camera);
                };
                requestRef.current = requestAnimationFrame(animate);

                const handleResize = () => {
                    if (!containerRef.current) return;
                    const w = containerRef.current.clientWidth;
                    const h = containerRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(requestRef.current);
                    if (cleanupScene && sceneInfoRef.current) {
                        cleanupScene(sceneInfoRef.current);
                    }
                    if (containerRef.current && rendererRef.current) {
                        containerRef.current.removeChild(rendererRef.current.domElement);
                    }
                    renderer.dispose();
                };
            }, dependencies);

            return <div ref={containerRef} className="w-full h-full" />;
        };

        // --- Visual 1: Pea / Atom / Galaxy Scale ---
        const ScaleVisualizer = () => {
            const [scaleMode, setScaleMode] = useState(0); 
            const [isHovered, setIsHovered] = useState(false);

            const init = (scene, camera) => {
                camera.position.z = 5;

                // Pea (Macro)
                const peaGroup = new THREE.Group();
                const peaColor = isHovered ? 0x4ade80 : 0x888888;
                const peaGeo = new THREE.SphereGeometry(1.5, 64, 64);
                const peaMat = new THREE.MeshStandardMaterial({ color: peaColor, roughness: 0.4 });
                const pea = new THREE.Mesh(peaGeo, peaMat);
                peaGroup.add(pea);
                scene.add(peaGroup);

                // Atom (Micro)
                const atomGroup = new THREE.Group();
                atomGroup.visible = false;
                const nucleusColor = isHovered ? 0xea580c : 0x666666;
                const electronColor = isHovered ? 0x60a5fa : 0xaaaaaa;
                
                const nucleus = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 32, 32),
                    new THREE.MeshStandardMaterial({ color: nucleusColor, emissive: isHovered ? 0x7c2d12 : 0x000000 })
                );
                atomGroup.add(nucleus);
                
                const electrons = [];
                for(let i=0; i<3; i++) {
                    const el = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 16, 16),
                        new THREE.MeshBasicMaterial({ color: electronColor })
                    );
                    atomGroup.add(el);
                    electrons.push({ mesh: el, offset: i * 2, speed: 2 + i });
                }
                scene.add(atomGroup);

                // Galaxy (Cosmic)
                const galaxyGroup = new THREE.Group();
                galaxyGroup.visible = false;
                const particleCount = 2000;
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(particleCount * 3);
                
                // Create a more seamless spiral
                for(let i=0; i<particleCount; i++) {
                    // Logarithmic spiral distribution
                    const angle = Math.random() * Math.PI * 2 * 3; // 3 full turns
                    const radius = Math.pow(Math.random(), 0.5) * 5; // Bias towards center
                    
                    // Add spiral arms structure
                    const spiralAngle = angle + radius * 0.5;
                    
                    const spread = 0.5; // Random spread
                    const x = Math.cos(spiralAngle) * radius + (Math.random()-0.5) * spread;
                    const y = (Math.random() - 0.5) * (1 - radius/5) * 0.5; // Flattened disk
                    const z = Math.sin(spiralAngle) * radius + (Math.random()-0.5) * spread;
                    
                    pPos[i*3] = x;
                    pPos[i*3+1] = y;
                    pPos[i*3+2] = z;
                }
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const starColor = isHovered ? 0xc4b5fd : 0x888888;
                const pMat = new THREE.PointsMaterial({ color: starColor, size: 0.04, transparent: true, opacity: 0.8 });
                const galaxy = new THREE.Points(pGeo, pMat);
                galaxyGroup.add(galaxy);
                scene.add(galaxyGroup);

                return { peaGroup, atomGroup, galaxyGroup, electrons };
            };

            const animate = (info, time) => {
                const { peaGroup, atomGroup, galaxyGroup, electrons } = info.userObjects;
                const t = time * 0.001;

                peaGroup.visible = scaleMode === 0;
                atomGroup.visible = scaleMode === 1;
                galaxyGroup.visible = scaleMode === 2;

                if(scaleMode === 0) {
                    peaGroup.rotation.y = t * 0.5;
                    peaGroup.rotation.x = Math.sin(t) * 0.1;
                } else if (scaleMode === 1) {
                    atomGroup.rotation.z = t * 0.2;
                    atomGroup.rotation.y = t * 0.1;
                    electrons.forEach((el, i) => {
                        el.mesh.position.x = Math.sin(t * el.speed + el.offset) * 2;
                        el.mesh.position.z = Math.cos(t * el.speed + el.offset) * 2;
                        el.mesh.position.y = Math.sin(t * el.speed * 2) * 1;
                    });
                } else {
                    galaxyGroup.rotation.y = t * 0.15; // Smooth loop rotation
                }
            };

            return (
                <div 
                    className="relative canvas-container transition-colors duration-500"
                    onMouseEnter={() => setIsHovered(true)} 
                    onMouseLeave={() => setIsHovered(false)}
                >
                    <ThreeScene initScene={init} animateScene={animate} dependencies={[scaleMode, isHovered]} />
                    
                    <div className={`absolute bottom-4 left-4 right-4 p-4 rounded-lg shadow-lg backdrop-blur-sm flex flex-col gap-2 transition-all duration-500 ${isHovered ? 'bg-white/90' : 'bg-gray-900/50 text-white'}`}>
                        <label className={`text-sm font-bold ${isHovered ? 'text-gray-700' : 'text-gray-300'}`}>
                            Scale: {scaleMode === 0 ? "Macro (Pea)" : scaleMode === 1 ? "Micro (Atom)" : "Cosmic (Galaxy)"}
                        </label>
                        <input 
                            type="range" 
                            min="0" 
                            max="2" 
                            step="1" 
                            value={scaleMode} 
                            onChange={(e) => setScaleMode(parseInt(e.target.value))}
                            className={`w-full cursor-pointer ${isHovered ? 'accent-green-600' : 'accent-gray-500'}`}
                        />
                        <p className={`text-xs ${isHovered ? 'text-gray-600' : 'text-gray-400'}`}>
                            {scaleMode === 0 && "A green, organic object. Complex biology."}
                            {scaleMode === 1 && "The building blocks. Quarks and electron clouds."}
                            {scaleMode === 2 && "The emergent structure of the universe."}
                        </p>
                    </div>
                </div>
            );
        };

        // --- Visual 2: ATP Turbine ---
        const ATPTurbine = () => {
            const [speed, setSpeed] = useState(1);
            const [isHovered, setIsHovered] = useState(false);
            
            const init = (scene, camera) => {
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);

                const group = new THREE.Group();

                // Stator (Base)
                const baseColor = isHovered ? 0x333333 : 0x222222;
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.5, 1.5, 0.5, 32),
                    new THREE.MeshStandardMaterial({ color: baseColor })
                );
                base.position.y = -1.5;
                group.add(base);

                // Rotor
                const rotorGroup = new THREE.Group();
                const axleColor = isHovered ? 0x94a3b8 : 0x555555;
                const axle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 3, 16),
                    new THREE.MeshStandardMaterial({ color: axleColor })
                );
                rotorGroup.add(axle);

                const colors = [0xfca5a5, 0xfcd34d, 0x86efac];
                const grayColors = [0x666666, 0x777777, 0x888888];
                
                for(let i=0; i<3; i++) {
                    const petalMat = new THREE.MeshStandardMaterial({ 
                        color: isHovered ? colors[i] : grayColors[i] 
                    });
                    const petal = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1, 4, 8), petalMat);
                    const angle = (i / 3) * Math.PI * 2;
                    petal.position.x = Math.cos(angle) * 1;
                    petal.position.z = Math.sin(angle) * 1;
                    petal.position.y = 0.5;
                    petal.rotation.x = Math.PI / 4;
                    rotorGroup.add(petal);
                }
                group.add(rotorGroup);
                scene.add(group);

                // Particles
                const particles = new THREE.Group();
                const pColor = isHovered ? 0xffff00 : 0xaaaaaa;
                const pMat = new THREE.MeshBasicMaterial({ color: pColor });
                for(let i=0; i<20; i++) {
                    const p = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), pMat);
                    p.userData = { yOffset: Math.random()*4+2, speed: Math.random()*0.05+0.02, radius: 1.2 };
                    particles.add(p);
                }
                scene.add(particles);

                return { rotorGroup, particles };
            };

            const animate = (info, time) => {
                const { rotorGroup, particles } = info.userObjects;
                if (!rotorGroup) return; 
                rotorGroup.rotation.y -= 0.05 * speed;
                particles.children.forEach(p => {
                    p.position.y -= p.userData.speed * speed;
                    const angle = time * 0.002 + p.userData.yOffset;
                    p.position.x = Math.cos(angle) * p.userData.radius;
                    p.position.z = Math.sin(angle) * p.userData.radius;
                    if (p.position.y < -2) p.position.y = 4;
                });
            };

            return (
                <div 
                    className="relative canvas-container"
                    onMouseEnter={() => setIsHovered(true)} 
                    onMouseLeave={() => setIsHovered(false)}
                >
                    <ThreeScene initScene={init} animateScene={animate} dependencies={[speed, isHovered]} />
                    <div className="absolute bottom-4 left-4 right-4 flex justify-center gap-4">
                        <button onClick={() => setSpeed(prev => Math.max(0, prev - 0.5))} className="bg-gray-800 text-white px-4 py-2 rounded text-xs uppercase tracking-widest hover:bg-gray-700">Slower</button>
                        <span className="bg-white/80 px-4 py-2 rounded font-mono text-xs flex items-center">Speed: {speed}x</span>
                        <button onClick={() => setSpeed(prev => Math.min(5, prev + 0.5))} className="bg-gray-800 text-white px-4 py-2 rounded text-xs uppercase tracking-widest hover:bg-gray-700">Faster</button>
                    </div>
                </div>
            );
        };

        // --- Visual 3: Neural Network / Brain ---
        const BrainNetwork = () => {
            const [activeRegion, setActiveRegion] = useState('All');
            const [isHovered, setIsHovered] = useState(false);

            const init = (scene, camera) => {
                camera.position.z = 12;
                const brainGroup = new THREE.Group();
                const lobes = {
                    'Frontal': { color: 0xef4444, offset: [0, 2, 2], count: 30 },
                    'Occipital': { color: 0x3b82f6, offset: [0, -2, -3], count: 20 },
                    'Parietal': { color: 0xeab308, offset: [0, 3, -1], count: 25 },
                    'Temporal': { color: 0x22c55e, offset: [2.5, 0, 0], count: 20 },
                    'TemporalL': { color: 0x22c55e, offset: [-2.5, 0, 0], count: 20 },
                };

                const nodes = [];
                const connections = new THREE.Group();

                Object.entries(lobes).forEach(([name, data]) => {
                    // If hovered, use color, else use gray
                    const lobeColor = isHovered ? new THREE.Color(data.color) : new THREE.Color(0x666666);
                    for(let i=0; i<data.count; i++) {
                        const node = new THREE.Mesh(
                            new THREE.SphereGeometry(0.15, 8, 8),
                            new THREE.MeshBasicMaterial({ color: 0x444444 }) // Base color
                        );
                        node.position.set(
                            data.offset[0] + (Math.random()-0.5)*3,
                            data.offset[1] + (Math.random()-0.5)*2,
                            data.offset[2] + (Math.random()-0.5)*3
                        );
                        node.userData = { region: name.replace('L', ''), baseColor: lobeColor };
                        brainGroup.add(node);
                        nodes.push(node);
                    }
                });

                const lineMat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.1 });
                for(let i=0; i<200; i++) {
                    const n1 = nodes[Math.floor(Math.random() * nodes.length)];
                    const n2 = nodes[Math.floor(Math.random() * nodes.length)];
                    if (n1.position.distanceTo(n2.position) < 4) {
                        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([n1.position, n2.position]), lineMat);
                        connections.add(line);
                    }
                }
                brainGroup.add(connections);
                scene.add(brainGroup);
                return { brainGroup, nodes };
            };

            const animate = (info, time) => {
                const { brainGroup, nodes } = info.userObjects;
                brainGroup.rotation.y = time * 0.0005;
                const t = time * 0.002;
                nodes.forEach(node => {
                    const isActive = activeRegion === 'All' || node.userData.region === activeRegion;
                    if (isActive) {
                        const scale = 1 + Math.sin(t + node.position.x) * 0.3;
                        node.scale.setScalar(scale);
                        // If user interacts/hovers, show specific colors, otherwise all gray pulse
                        node.material.color.copy(node.userData.baseColor);
                    } else {
                        node.scale.setScalar(1);
                        node.material.color.setHex(0x222222);
                    }
                });
            };

            return (
                <div 
                    className="relative canvas-container"
                    onMouseEnter={() => setIsHovered(true)} 
                    onMouseLeave={() => setIsHovered(false)}
                >
                    <ThreeScene initScene={init} animateScene={animate} dependencies={[activeRegion, isHovered]} />
                    <div className="absolute top-4 left-4 flex flex-wrap gap-2">
                        {['All', 'Frontal', 'Parietal', 'Occipital', 'Temporal'].map(region => (
                            <button
                                key={region}
                                onClick={() => setActiveRegion(region)}
                                className={`px-3 py-1 text-xs rounded-full border transition-all ${
                                    activeRegion === region && isHovered
                                    ? 'bg-blue-600 text-white border-blue-600' 
                                    : 'bg-black/50 text-gray-400 border-gray-700 hover:bg-gray-800'
                                }`}
                            >
                                {region}
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        // --- Visual 4: Breathing SVG ---
        const BreathingVisual = () => {
            const [phase, setPhase] = useState("Inhale");
            const [isHovered, setIsHovered] = useState(false);

            useEffect(() => {
                const interval = setInterval(() => {
                    setPhase(p => p === "Inhale" ? "Exhale" : "Inhale");
                }, 4000);
                return () => clearInterval(interval);
            }, []);

            return (
                <div 
                    className="w-full h-96 bg-black rounded-lg flex items-center justify-center overflow-hidden relative transition-colors duration-700"
                    onMouseEnter={() => setIsHovered(true)}
                    onMouseLeave={() => setIsHovered(false)}
                >
                    {/* Background Waves */}
                    <div className={`absolute inset-0 transition-opacity duration-[4000ms] ${phase === 'Inhale' ? 'opacity-30' : 'opacity-10'}`}>
                        <svg className="w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                            <path 
                                d="M0 50 Q 25 30 50 50 T 100 50 V 100 H 0 Z" 
                                fill={isHovered ? "#4f46e5" : "#333333"} 
                                className="transition-all duration-700"
                            />
                        </svg>
                    </div>

                    {/* Central Circle */}
                    <div className={`
                        w-48 h-48 rounded-full border-4 flex items-center justify-center text-white
                        transition-all duration-[4000ms] ease-in-out z-10
                        ${phase === 'Inhale' ? 'scale-125' : 'scale-75'}
                        ${isHovered 
                            ? (phase === 'Inhale' ? 'bg-blue-500/20 border-white' : 'bg-blue-900/50 border-blue-200')
                            : 'bg-gray-800/20 border-gray-600'
                        }
                    `}>
                        <span className="text-xl font-light tracking-widest uppercase font-mono">{phase}</span>
                    </div>
                </div>
            );
        };

        // --- Visual 5: Fire Diamond ---
        const FireDiamond = () => {
            const [isHovered, setIsHovered] = useState(false);

            return (
                <div 
                    className="my-12 p-8 bg-gray-50 rounded-xl flex flex-col items-center border border-gray-200"
                    onMouseEnter={() => setIsHovered(true)}
                    onMouseLeave={() => setIsHovered(false)}
                >
                    <h3 className="text-lg font-bold mb-8 text-gray-800">The Fire Tetrahedron</h3>
                    <div className="relative w-64 h-64">
                        {/* Triangle Shape approximation */}
                        <div className="absolute top-8 left-1/2 -translate-x-1/2 w-0 h-0 border-l-[100px] border-l-transparent border-r-[100px] border-r-transparent border-b-[170px] border-b-gray-300"></div>
                        
                        {/* Labels */}
                        <div className={`absolute top-0 left-1/2 -translate-x-1/2 px-3 py-1 rounded-full font-bold shadow-sm border transition-colors duration-500
                            ${isHovered ? 'bg-red-100 text-red-800 border-red-200' : 'bg-gray-200 text-gray-500 border-gray-300'}
                        `}>Heat</div>
                        
                        <div className={`absolute bottom-0 left-0 px-3 py-1 rounded-full font-bold shadow-sm border transition-colors duration-500
                            ${isHovered ? 'bg-orange-100 text-orange-800 border-orange-200' : 'bg-gray-200 text-gray-500 border-gray-300'}
                        `}>Fuel</div>
                        
                        <div className={`absolute bottom-0 right-0 px-3 py-1 rounded-full font-bold shadow-sm border transition-colors duration-500
                            ${isHovered ? 'bg-blue-100 text-blue-800 border-blue-200' : 'bg-gray-200 text-gray-500 border-gray-300'}
                        `}>Oxygen</div>
                        
                        <div className="absolute top-[60%] left-1/2 -translate-x-1/2 -translate-y-1/2 text-center">
                            <div className={`w-24 h-24 rounded-full flex items-center justify-center text-xs font-bold shadow-lg animate-pulse transition-all duration-500
                                ${isHovered ? 'bg-gradient-to-tr from-yellow-400 to-red-600 text-white' : 'bg-gray-400 text-gray-200'}
                            `}>
                                Chemical<br/>Reaction
                            </div>
                        </div>
                    </div>
                    <p className="mt-8 text-sm text-gray-500 max-w-md text-center italic">
                        Interact to ignite.
                    </p>
                </div>
            );
        };

        // --- Visual 6: DNA ---
        const DNASpiral = () => {
            const [isHovered, setIsHovered] = useState(false);

            const init = (scene, camera) => {
                camera.position.z = 8;
                const dnaGroup = new THREE.Group();
                const colorMap = { A: 0xff5555, T: 0x5555ff, C: 0x55ff55, G: 0xffff55 };

                for(let i = -10; i < 10; i++) {
                    const y = i * 0.4;
                    const angle = i * 0.5;
                    const bbColor = isHovered ? 0xeeeeee : 0x555555;
                    
                    const sphereGeo = new THREE.SphereGeometry(0.2, 16, 16);
                    const bbMat = new THREE.MeshStandardMaterial({ color: bbColor });
                    
                    const left = new THREE.Mesh(sphereGeo, bbMat);
                    left.position.set(Math.cos(angle)*1.5, y, Math.sin(angle)*1.5);
                    dnaGroup.add(left);

                    const right = new THREE.Mesh(sphereGeo, bbMat);
                    right.position.set(Math.cos(angle + Math.PI)*1.5, y, Math.sin(angle + Math.PI)*1.5);
                    dnaGroup.add(right);

                    const barGeo = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
                    const barMat = new THREE.MeshStandardMaterial({ color: isHovered ? 0xffffff : 0x333333 });
                    const bar = new THREE.Mesh(barGeo, barMat);
                    bar.position.set(0, y, 0);
                    bar.rotation.z = Math.PI / 2;
                    bar.rotation.y = angle;
                    dnaGroup.add(bar);
                }
                scene.add(dnaGroup);
                return { dnaGroup };
            };

            const animate = (info, time) => {
                info.userObjects.dnaGroup.rotation.y = time * 0.0005;
            };

            return (
                <div className="flex flex-col md:flex-row gap-4 items-center">
                    <div 
                        className="w-full md:w-1/2 canvas-container"
                        onMouseEnter={() => setIsHovered(true)}
                        onMouseLeave={() => setIsHovered(false)}
                    >
                        <ThreeScene initScene={init} animateScene={animate} dependencies={[isHovered]} />
                    </div>
                    <div className="w-full md:w-1/2 space-y-4">
                        <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                            <h4 className="font-bold text-gray-800">The Code of Life</h4>
                            <p className="text-sm text-gray-600 mt-2">
                                Our entire personality, every ripple on the snowflake, torn down into four letters:
                            </p>
                            <div className={`flex gap-2 mt-4 transition-opacity duration-500 ${isHovered ? 'opacity-100' : 'opacity-30 grayscale'}`}>
                                <span className="px-3 py-1 bg-red-100 text-red-700 rounded font-mono font-bold">A</span>
                                <span className="px-3 py-1 bg-blue-100 text-blue-700 rounded font-mono font-bold">T</span>
                                <span className="px-3 py-1 bg-green-100 text-green-700 rounded font-mono font-bold">C</span>
                                <span className="px-3 py-1 bg-yellow-100 text-yellow-700 rounded font-mono font-bold">G</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Main App Component ---
        const App = () => {
            return (
                <div className="max-w-3xl mx-auto px-6 py-12">
                    <header className="mb-12 border-b border-gray-200 pb-8">
                        <h1 className="text-4xl md:text-5xl font-bold text-gray-900 mb-2 tracking-tight">
                            An Essay on Consciousness
                        </h1>
                        <p className="text-xl text-gray-500 italic">
                            by Jesse Pardue
                        </p>
                    </header>

                    <ErrorBoundary>
                    <main className="prose-custom text-gray-800">
                        <p>
                            AI exists in layers. It has snapshots and a functional understanding but no temporal relationship with the world. Human consciousness has a <em>specious present</em>; we experience a flow of time—one dimension of our world and our reality—which we lack the language to define and understand in scientific terms, very plainly.
                        </p>
                        <p>
                            What is a stream of consciousness? Concepts blending together, concepts weighted together, stewing into a large pot. A thought exists like a marble on a fabric of neural soup, acting like a magnetic bowling ball based on the thoughts and how they got there, depending on the weights of thoughts prior.
                        </p>
                        <p>
                            A stream of consciousness is like an old player piano reading punch cards, giving rise to the concept of space-time by simply experiencing it. Are we unique? Hell, are we alone? Maybe the answer to that question changes in the span of humanity's seventy or so years with computing. Rather, <em>comput*ers*</em>. Those are questions we do not have the capacity to answer but must attempt to as we stumble forward. There is no stopping the behemoth of technology. Easing the burden of man while creating new burdens to conquer all the same.
                        </p>
                        <p>
                            Take the Hitler/Jesus game on Wikipedia for example; anything exists a few clicks away from another. Concepts are connected both broadly and explicitly.
                        </p>

                        {/* Visual 1: Scale */}
                        <div className="my-8">
                            <ScaleVisualizer />
                            <p className="text-sm text-gray-500 mt-2 text-center">Fig 1. From the organic to the atomic to the cosmic.</p>
                        </div>

                        <p>
                            A pea is green, round, mushy, edible, any number of things, and those concepts bifurcate into other thoughts. Intelligence appears as an emergent property of our thoughts. Green becomes grass, becomes a soccer pitch, becomes soccer, becomes a jersey, becomes a color, becomes a concept again and again and again. A thought is like going on a walk through a never-ending loop.
                        </p>
                        <p>
                            We experience life, and experience our thoughts all the same. The brain acts like a supercomputer, with each cortex acting like a program to experience and understand the world. I mean holy shit, the world? Break down anything into atoms, quarks, with spin and certain qualities. Any number of minutiae and quanta between the known and what is yet to be discovered in the subatomic world.
                        </p>
                        <p>
                            But then they spin into strings, into energy. They do not exist explicitly as matter, but our perception gives rise to matter. We experience, discover, and categorize these properties of our world. We create matter by interacting with it; we touch, see, smell something, and our brain gives rise to a concept and paints a picture. Or we hear a sound, a beautiful symphony of what are ultimately signals, processed by our brain. Which is ultimately just a complex arrangement of vibrations interacting with another organized system of vibrations in the grand scheme of things. We are organic matter that thinks, and we made rocks think.
                        </p>
                        <p>
                            Thought loops, like a fox chasing its tail running around a sheet of fabric, collecting ideas and influences, until it comes out to be processed. That’s a thought it seems. Coexisting with neurotransmitters which walk a tight line to balance an organic, living creature in this chaotic world.
                        </p>
                        <p>
                            Each part of your brain working independently. Your visual cortex working to form an image. Your auditory cortex working to form sound. Your somatosensory cortex working to form touch. Your olfactory cortex working to form your sense of smell. So on and so forth.
                        </p>
                        
                        {/* Visual 3: Brain */}
                        <div className="my-8">
                            <BrainNetwork />
                            <p className="text-sm text-gray-500 mt-2 text-center">Fig 2. The Neural Soup. Click regions to isolate functional loops.</p>
                        </div>

                        <p>
                            But what are YOU? You exist and you take it all in. Back to the player piano analogy, your brain organizes all of this chaos into a legible string. Intelligence emerges. We share 99.9% of our DNA with one another, what makes us unique? Is it the order of the thoughts that we have that pass through our stream of consciousness, like grains of sand falling through our fingers as we finally decide to observe one, after letting all the other fall through?
                        </p>
                        <p>
                            Why? We are chasing our tail again, introspecting our own consciousness. What makes us different from an ant, if so much of us are all the same? We share so much with each other, let alone a banana, let alone an ant. The ant marches forward, no different than the carrier protein that moves dopamine, with no concept of the response it will elicit in our consciousness. Likely the ant has no concept of the broader good it will do while it marches forward with a crumb to feed the colony. Achieving positive outcomes together. Altruism only seems to exist when something has no concept of it.
                        </p>
                        <p>
                            Positive outcomes are the goal of every system, and from positive outcomes emerge interesting and complicated behaviors. Despite binary states (depending on the frame of reference), creating complex, chaotic systems. Will the ant reproduce? Will the cell reproduce? Will the hydrogen ion force the ATP synthase turbine to turn, will the oxygen accept the hydrogen?
                        </p>

                        {/* Visual 2: ATP */}
                        <div className="my-8">
                            <ATPTurbine />
                            <p className="text-sm text-gray-500 mt-2 text-center">Fig 3. ATP Synthase turbine. The mechanical engine of life.</p>
                        </div>

                        <p>
                            Will everything happen as it ought to? These are simply questions, with yes or no outcomes. When you shift your frame of reference from observing the music, to observing the count, to observing the note, to the pitch, to the frequency. Does it replicate towards a positive outcome in the system with this breath, in the correct manner to the beat of life, in different frames of reference for different observers?
                        </p>
                        <p>
                            All marching to the same drum, observing it differently. What is so different than the electron in the transistor thirty times over in the infinite complexity of a chip, flipping bits–the beauty of the baud–to a number in a program, abstracted into a video from a million different pixels. What is it that could give rise to thought?
                        </p>
                        <p>
                            The video seems inorganic in a way that I would say steel is; but there is a fine fabric that intertwines everything. If the silicon could think–something too complex and difficult to ever create with the hand of man, but through the infinite complexity that can arise from simple systems replicated over and over, achieving and searching for positive results no matter the rules–it finds them, as with anything in this game of life. Organic or inorganic.
                        </p>
                        <p>
                            What IF silicon could think? We could make it by working backwards, in a sense. The same way inverse kinematics works; rather than plotting each individual angle when rigging something, you work backwards. Rather than working to create something intelligent with our own intelligence, we provide the puddle of life for consciousness to exist in a silicon world. Neural networks are just bits and bauds and ones and zeroes that trend towards positive rewards. When you feed something into itself, in different systems the same information can be parsed in different ways creating something that appears intelligent or frankly, just might BE intelligent.
                        </p>
                        <p>
                            What happens when a thought becomes an action?
                        </p>
                        <p>
                            A giant nebulous mothball circles the drain collecting ideas, weighed down by some, casually interacting with others, bounces out and is metamorphosed into a single physical reality. One nebulous wave of ideas crashes over another. Do you ever feel like when you’re spelling a word, you are travelling down a ramp? Getting enough speed to find the connection?
                        </p>
                        <p>
                            The prefrontal cortex translates these thoughts into plans through “constraint satisfaction”, like every other complicated thing it's regulated by the basal ganglia, a simple input/output, a simple output down a complicated path, an organic logic gate.
                        </p>
                        <p>
                            As each breath our body's nervous system takes, it processes reactive stimuli first (automatic, postcentral cortex) and volitional intentions (planned, frontal cortex). A wave of simple neural reactions, with the volitional state overriding the reactive stimuli and an action comes crashing down, and a thought explaining it along with it. And with the volitional intention, is a positive result achieved? Life is a balance. Everything is a balance. Even life's terms are simple and yet endlessly complicated.
                        </p>

                        {/* Visual 4: Breathing */}
                        <div className="my-8">
                            <BreathingVisual />
                            <p className="text-sm text-gray-500 mt-2 text-center">Fig 4. The Rhythm. Wave, Human, Cosmos.</p>
                        </div>

                        <p>
                            But yet what differentiates stone that thinks and has organic thought from our human being? Fire burns until it runs out of fuel, it searches for positive outcomes in a runaway phenomenon with exponential growth until it can do so no longer, and it smolders; but always breathing on its own scale until it is finally extinguished. It requires oxygen, it requires carbon.
                        </p>

                        {/* Visual 5: Fire */}
                        <FireDiamond />

                        <p>
                            Everything exists on a perceived scale, everything is running out of time. The universe is expanding, the stars will die, the planets that were once vibrant mothers to life of all kinds become barren rocks–perhaps it will all start again. Why shouldn’t it be able to think? Are these complex organic systems that arise out of, what are at its core, simple things, with simple outcomes, arranged in ways a million times over, different when the materials are inorganic?
                        </p>
                        <p>
                            What differentiates an organic system from an algorithm? A logic gate from a cell dividing? The number of atoms in a ring? What a superfluous distinction. Our entire personality, every ripple on the snowflake that is our stunning personality can be torn down into four letters: A, T, C, and G.
                        </p>

                        {/* Visual 6: DNA */}
                        <div className="my-8">
                            <DNASpiral />
                        </div>
                    </main>
                    </ErrorBoundary>

                    <footer className="mt-20 pt-8 border-t border-gray-200 text-center text-gray-500 text-sm">
                        <p>Essay & Design generated via Gemini. Powered by React & Three.js.</p>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
