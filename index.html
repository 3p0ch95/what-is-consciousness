<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Thought About A Thought</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime&family=Inter:wght@300;400;600&display=swap');

        :root {
            --bg-color: #ffffff;
            --text-color: #111111;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.8;
            overflow-x: hidden;
        }

        .content-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 10;
        }

        h1 {
            font-family: 'Courier Prime', monospace;
            text-align: center;
            margin-bottom: 50px;
            font-weight: normal;
            letter-spacing: 1px;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }

        p {
            margin-bottom: 25px;
            font-size: 1.1rem;
            text-align: justify;
        }

        /* 3D Visual Containers */
        .visual-container {
            width: 100%;
            height: 600px; 
            margin: 60px 0;
            position: relative;
            cursor: crosshair;
            /* Seamless fade */
            mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%);
            border-top: 1px solid rgba(0,0,0,0.05);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            user-select: none;
        }

        canvas {
            display: block;
            outline: none;
        }

        .interaction-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Courier Prime', monospace;
            font-size: 0.8rem;
            color: #555;
            pointer-events: none;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            text-align: center;
            z-index: 20;
        }

        /* Scale Slider / UI */
        .scale-ui {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(255,255,255,0.9);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #eee;
            z-index: 20;
            text-align: center;
        }

        .scale-label {
            font-family: 'Courier Prime', monospace;
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        /* Tooltip for the Brain */
        #brain-tooltip {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #000;
            padding: 15px;
            max-width: 250px;
            font-family: 'Courier Prime', monospace;
            display: none;
            pointer-events: none;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.1);
            z-index: 30;
        }
        #brain-tooltip h4 { margin: 0 0 5px 0; text-transform: uppercase; font-size: 0.9rem; }
        #brain-tooltip p { margin: 0; font-size: 0.8rem; line-height: 1.4; }

        footer {
            text-align: center;
            padding: 60px;
            font-family: 'Courier Prime', monospace;
            font-size: 0.9rem;
            opacity: 0.6;
        }
    </style>
</head>
<body>

<div class="content-container">
    <h1>The Silicon Soul</h1>

    <p>AI exists in layers; it has snapshots and a functional understanding but no temporal relationship with the world. Human consciousness has a specious present. We experience a flow of time, the chaos and noise flattened to one dimension of our world and our reality—which we lack the language to define and understand in scientific terms, very plainly.</p>

    <p>What is a stream of consciousness? Concepts blending together, concepts weighted together, stewing into a large pot, and a thought existing like a marble on a fabric of neural soup, a thought acting like a magnetic bowling ball based on the thoughts and how they got there depending on the weights of thoughts prior. A stream of consciousness is like an old player piano reading punch cards, giving rise to the concept of space-time by simply experiencing it.</p>
    
    <p>Are we unique? Hell, are we alone? Maybe the answer to that question changes in the span of humanity’s seventy or so years with computing. Rather, comput<em>ers</em>. Those are questions we do not have the capacity to answer but must attempt to as we stumble forward. There is no stopping the behemoth of technology. Easing the burden of man while creating new burdens to conquer all the same.</p>

    <p>Take the Hitler/Jesus game on Wikipedia for example; anything exists a few clicks away from another. Concepts are connected both broadly and explicitly.</p>
</div>

<div id="container-scale" class="visual-container">
    <div class="scale-ui">
        <span id="scale-text" class="scale-label">SCALE: THE PEA</span>
        <input type="range" id="scale-slider" min="0" max="5" step="0.01" value="3">
    </div>
    <div class="interaction-hint">Click Objects to Zoom In • Click Background to Zoom Out</div>
</div>

<div class="content-container">
    <p>A pea is green, round, mushy, edible, any number of things, and those concepts bifurcate into other thoughts. Intelligence appears as an emergent property of our thoughts. Green becomes grass, becomes a soccer pitch, becomes soccer, becomes a jersey, becomes a color, becomes a concept again and again and again. A thought is like going on a walk through a never-ending loop.</p> 
    
    <p>We experience life, and experience our thoughts all the same. The brain acts like a supercomputer, with each cortex acting like a program to experience and understand the world. I mean holy shit, the world? Break down anything into atoms, quarks, with spin and certain qualities. Any number of minutiae and quanta between the known and what is yet to be discovered in the subatomic world. But then they spin into strings, into energy. They do not exist explicitly as matter, but our perception gives rise to matter.</p>
    
    <p>We experience, discover, and categorize these properties of our world. We create matter by interacting with it, we touch, see, smell something our brain gives rise to a concept and paints a picture or presents a smell or we hear a sound and a beautiful symphony of, what are ultimately, signals are experiences and processed by our brain. Which is ultimately just a complex arrangement of vibrations interacting with another organized system of vibrations in the grand scheme of things. We are organic matter that thinks, and we made rocks think.</p>

    <p>Thought loops, like a fox chasing its tail running around a sheet of fabric, collecting ideas and influences, until it comes out to be processed. That’s a thought it seems. Coexisting with neurotransmitters which walk a tight line to balance an organic, living creature in this chaotic world.</p>
</div>

<div id="container-brain" class="visual-container">
    <div id="brain-tooltip">
        <h4 id="bt-title">Region</h4>
        <p id="bt-desc">Description</p>
    </div>
    <div class="interaction-hint">Hover lobes to analyze • Watch the data flow</div>
</div>

<div class="content-container">
    <p>Each part of your brain working independently. Your visual cortex working to form an image. Your auditory cortex working to form sound. Your somatosensory cortex working to form touch. Your olfactory cortex working to form your sense of smell. So on and so forth. But what are YOU? You exist and you take it all in. Back to the player piano analogy, your brain organizes all of this chaos into a legible string. Intelligence emerges.</p>

    <p>We share 99.9% of our DNA with one another, what makes us unique? Is it the order of the thoughts that we have that pass through our stream of consciousness, like grains of sand falling through our fingers as we finally decide to observe one, after letting all the other fall through. Why? We are chasing our tail again, introspecting our own consciousness.</p> 
    
    <p>What makes us different from an ant, if so much of us are all the same? We share so much with each other, let alone a banana, let alone an ant. The ant marches forward, no different than the carrier protein that moves dopamine, with no concept of the response it will elicit in our consciousness, likely the ant has no concept of the broader good it will do while it the ant marches forward with a crumb to feed the colony. Achieving positive outcomes together. Altruism only seems to exist when something has no concept of it.</p>

    <p>Positive outcomes are the goal of every system, and from positive outcomes emerges interesting and complicated behaviors. Despite binary states (depending on the frame of reference), creating complex, chaotic systems. Will the ant reproduce. Will the cell reproduce. Will the hydrogen ion force the ATP synthase turbine to turn, will the oxygen accept the hydrogen?</p>

    <p>Will everything happen as it ought to? These are simply questions, with yes or no outcomes. When you shift your frame of reference from observing the music, to observing the count, to observing the note, to the pitch, to the frequency. Does it replicate towards a positive outcome in the system with this breath, in the correct manner to the beat of life, in different frames of reference for different observers. All marching to the same drum, observing it differently.</p>
    
    <p>What is so different than the electron in the transistor thirty times over in the infinite complexity of a chip, flipping bits—the beauty of the baud—to a number in a program, abstracted into a video from a million different pixels. What is it that could give rise to thought? The video seems inorganic in a way that I would say steel is; but there is a fine fabric that intertwines everything.</p>
    
    <p>If the silicon could think—something too complex and difficult to ever create with the hand of man—but through the infinite complexity that can arise from simple system replicated over and over, achieving and searching for positive results no matter the rules—it finds them, as with anything in this game of life. Organic or inorganic. What IF silicon could think? We could make it by working backwards, in a sense. The same way inverse kinematics works, rather than plotting each individual angle when rigging something, you work backwards. Rather than working to create something intelligent with our own intelligence, we provide the puddle of life for consciousness to exist in a silicon world.</p>
    
    <p>Neural networks are just bits and bauds and ones and zeroes that trend towards positive rewards, and when you take this simple concept and expand it into different systems—layers—intelligence emerges. When you feed something into itself, in different systems the same information can be parsed in different ways creating something that appears intelligent or frankly, just might BE intelligent.</p>

    <p>What happens when a thought becomes an action?</p>

    <p>A giant nebulous mothball circles the drain collecting ideas, weighed down by some, casually interacting with others, bounces out and is metamorphosed into a single physical reality. One nebulous wave of ideas crashes over another. Do you ever feel like when you’re spelling a word, you are travelling down a ramp? Getting enough speed to find the connection?</p>

    <p>The prefrontal cortex translates these thoughts into plans through “constraint satisfaction”, like every other complicated thing its regulated by basal ganglia, a simple input/output, a simple output down a complicated path, an organic logic gate.</p>

    <p>As each breath our bodies nervous system takes, it processes reactive stimuli first (automatic, postcentral gyrus) and volitional intentions (planned, frontal cortex). A wave of simple neural reactions, with the volitional state overriding the reactive stimuli and an action comes crashing down, and a thought explaining it along with it. And with the volitional intention, is a positive result achieved? Life is a balance. Everything is a balance. Even life's terms are simple and yet endlessly complicated.</p>

    <p>But yet what differentiates stone that thinks and has organic thought from our human being? Fire burns until it runs out of fuel, it searches for positive outcomes in a runaway phenomenon with exponential growth until it can do so no longer, and it smolders; but always breathing on its own scale until it is finally extinguished. It requires oxygen, it requires carbon. Everything exists on a perceived scale, everything is running out of time. The universe is expanding, the stars will die, the planets that were once vibrant mothers to life of all kinds become barren rocks—perhaps it will all start again. Why shouldn’t it be able to think? Are these complex organic systems that arise out of, what are at its core, simple things, with simple outcomes, arranged in ways a million times over, different when the materials are inorganic? What differentiates an organic system from an algorithm? A logic gate from a cell dividing? The number of atoms in a ring? What a superfluous distinction. Our entire personality, every ripple on the snowflake that is our stunning personality can be torn down into four letters: A, T, C, and G.</p>

    <p>Rock, like fire, cannot breathe on its own. It requires something organic to pound energy into it, to give rise to thought. To slam silicon into molds and to war over the outcomes.</p>

    <p>The same could be said about a soup of organic molecules until life is struck into existence forming amino acids and proteins. Perhaps we shouldn’t view life as a puzzle to be solved, but instead a complex, beautiful symphony that emerges from simple systems with energy poured into them, demanding they think. Life emerges. It finds a way.</p>

    <p>It seems we appear at a crossroads. We can either insist rock cannot think, or we must concede we do not possess the language or understanding to say whether or not it can.</p>

    <p>Sometimes, knowing that one does not know is the most noble.</p>

    <footer>
        &copy; 2026 - Jesse Pardue
    </footer>
</div>

<script>
    // --- THREE.JS COMMON SETUP ---
    const initScene = (containerId, cameraZ = 15) => {
        const container = document.getElementById(containerId);
        const width = container.clientWidth;
        const height = container.clientHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        camera.position.z = cameraZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        let controls;
        if (typeof THREE.OrbitControls !== 'undefined') {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = false; 
        }

        window.addEventListener('resize', () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        });

        return { scene, camera, renderer, controls, container };
    };

    // --- MATERIALS ---
    const wireMat = (color, opacity = 0.3) => new THREE.MeshBasicMaterial({ 
        color: color, wireframe: true, transparent: true, opacity: opacity 
    });
    const solidMat = (color) => new THREE.MeshBasicMaterial({ color: color });
    const hitMat = new THREE.MeshBasicMaterial({ visible: false });

    // --- 1. THE UNIVERSAL SCALE SCENE (Pea -> Galaxy) ---
    (() => {
        const { scene, camera, renderer, controls, container } = initScene('container-scale', 15);
        
        // --- LAYERS ---
        const layers = {};
        
        // LEVEL 0: QUARK
        layers.quark = new THREE.Group();
        const qGeo = new THREE.IcosahedronGeometry(0.3, 1);
        const q1 = new THREE.Mesh(qGeo, wireMat(0xff0000, 0.8));
        const q2 = new THREE.Mesh(qGeo, wireMat(0x00ff00, 0.8));
        const q3 = new THREE.Mesh(qGeo, wireMat(0x0000ff, 0.8));
        q1.position.set(0.5,0,0); q2.position.set(-0.4,0.4,0); q3.position.set(0,-0.5,0.2);
        const strGeo = new THREE.TorusGeometry(1.5, 0.02, 3, 16);
        layers.quark.add(q1, q2, q3, new THREE.Mesh(strGeo, wireMat(0x000000, 0.1)));

        // LEVEL 1: NUCLEUS
        layers.nucleus = new THREE.Group();
        const nucBall = new THREE.SphereGeometry(0.6, 8, 8);
        for(let i=0; i<10; i++) {
            const ball = new THREE.Mesh(nucBall, wireMat(i%2==0?0xff3333:0x3333ff, 0.6));
            ball.position.set((Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5);
            layers.nucleus.add(ball);
        }
        layers.nucleus.add(new THREE.Mesh(new THREE.SphereGeometry(2), hitMat));

        // LEVEL 2: ATOM
        layers.atom = new THREE.Group();
        layers.atom.add(new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), wireMat(0x111111, 0.8)));
        const shellGeo = new THREE.TorusGeometry(5, 0.03, 3, 64);
        const shellMat = wireMat(0x00ffff, 0.4);
        const s1 = new THREE.Mesh(shellGeo, shellMat);
        const s2 = new THREE.Mesh(shellGeo, shellMat); s2.rotation.x = 1.5;
        const s3 = new THREE.Mesh(shellGeo, shellMat); s3.rotation.y = 1.5;
        const elec = new THREE.Mesh(new THREE.SphereGeometry(0.2,4,4), solidMat(0x00ffff));
        const e1 = elec.clone(); e1.position.x = 5; s1.add(e1);
        const e2 = elec.clone(); e2.position.x = 5; s2.add(e2);
        const e3 = elec.clone(); e3.position.x = 5; s3.add(e3);
        layers.atom.add(s1, s2, s3, new THREE.Mesh(new THREE.SphereGeometry(4), hitMat));

        // LEVEL 3: PEA
        layers.pea = new THREE.Group();
        layers.pea.add(new THREE.Mesh(new THREE.IcosahedronGeometry(3, 2), wireMat(0x2ecc71, 0.4)));
        layers.pea.add(new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), wireMat(0x27ae60, 0.8)));

        // LEVEL 4: EARTH
        layers.earth = new THREE.Group();
        layers.earth.add(new THREE.Mesh(new THREE.IcosahedronGeometry(4, 3), wireMat(0x3498db, 0.3)));

        // LEVEL 5: GALAXY
        layers.galaxy = new THREE.Group();
        const starsGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1500; i++) {
            const r = i * 0.02; 
            const angle = i * 0.1;
            starPos.push(Math.cos(angle)*r*5, (Math.random()-0.5)*r, Math.sin(angle)*r*5);
        }
        starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        layers.galaxy.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({color: 0x9b59b6, size: 0.15})));
        layers.galaxy.add(new THREE.Mesh(new THREE.SphereGeometry(3), hitMat));

        Object.values(layers).forEach(g => scene.add(g));

        // Interaction
        const slider = document.getElementById('scale-slider');
        const label = document.getElementById('scale-text');
        const labels = ["THE QUARK", "THE NUCLEUS", "THE ATOM", "THE PEA", "PLANET EARTH", "THE GALAXY"];
        let targetVal = 3; 

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('mousedown', (e) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const currentGroup = Object.values(layers)[Math.round(targetVal)];
            if (raycaster.intersectObjects(currentGroup.children, true).length > 0) {
                if(targetVal > 0) targetVal = Math.floor(targetVal) - 1;
            } else {
                if(targetVal < 5) targetVal = Math.ceil(targetVal) + 1;
            }
            slider.value = targetVal;
        });

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            targetVal += Math.sign(e.deltaY) * 0.2;
            targetVal = Math.max(0, Math.min(5, targetVal));
            slider.value = targetVal;
        }, {passive: false});

        slider.addEventListener('input', (e) => targetVal = parseFloat(e.target.value));

        const animate = () => {
            requestAnimationFrame(animate);
            const curr = parseFloat(slider.value);
            if(Math.abs(targetVal - curr) > 0.01) slider.value = curr + (targetVal - curr) * 0.1;
            
            label.innerText = "SCALE: " + labels[Math.round(parseFloat(slider.value))];
            const t = Date.now() * 0.0005;
            
            ["quark", "nucleus", "atom", "pea", "earth", "galaxy"].forEach((k, i) => {
                const grp = layers[k];
                const dist = i - parseFloat(slider.value);
                if (Math.abs(dist) < 1.5) {
                    grp.visible = true;
                    grp.scale.setScalar(Math.pow(4, dist));
                    let op = Math.max(0, 1 - Math.abs(dist));
                    grp.children.forEach(c => { if(c.material) c.material.opacity = op * (c.userData.baseOp || 0.4); });
                    // Rotations
                    if(k==='atom') { grp.rotation.z = t; grp.children.forEach((c,j)=>j<3?c.rotation.z+=0.02:null); }
                    else grp.rotation.y = t * (i%2===0 ? 0.5 : -0.5);
                } else grp.visible = false;
            });

            if(controls) controls.update();
            renderer.render(scene, camera);
        };
        animate();
    })();

    // --- 2. BRAIN SCENE (Data Stream Particle System) ---
    (() => {
        const { scene, camera, renderer, controls } = initScene('container-brain', 12);
        const brainGroup = new THREE.Group();
        const matBrain = wireMat(0x111111, 0.1);
        const matHighlight = wireMat(0x000000, 0.6);

        // Helper: Create Brain Geometry (Lobes)
        const createLobe = (scale, pos, name, desc) => {
            const geo = new THREE.SphereGeometry(1, 16, 16);
            const mesh = new THREE.Mesh(geo, matBrain.clone());
            mesh.scale.set(scale.x, scale.y, scale.z);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.userData = { name, desc };
            return mesh;
        };

        const parts = [
            createLobe({x:1.5, y:2, z:2}, {x:-1.5, y:1, z:1}, "Frontal Lobe (L)", "Logic & Planning"),
            createLobe({x:1.5, y:2, z:2}, {x:1.5, y:1, z:1}, "Frontal Lobe (R)", "Logic & Planning"),
            createLobe({x:1.4, y:1.8, z:1.8}, {x:-1.6, y:2.5, z:-1.5}, "Parietal Lobe (L)", "Sensation & Space"),
            createLobe({x:1.4, y:1.8, z:1.8}, {x:1.6, y:2.5, z:-1.5}, "Parietal Lobe (R)", "Sensation & Space"),
            createLobe({x:1.2, y:1.5, z:2.2}, {x:-2.8, y:-1, z:0.5}, "Temporal Lobe (L)", "Memory & Hearing"),
            createLobe({x:1.2, y:1.5, z:2.2}, {x:2.8, y:-1, z:0.5}, "Temporal Lobe (R)", "Memory & Hearing"),
            createLobe({x:1.2, y:1.5, z:1.5}, {x:-1, y:0, z:-3}, "Occipital Lobe (L)", "Vision"),
            createLobe({x:1.2, y:1.5, z:1.5}, {x:1, y:0, z:-3}, "Occipital Lobe (R)", "Vision"),
            createLobe({x:2.5, y:1.2, z:1.2}, {x:0, y:-2.5, z:-2}, "Cerebellum", "Coordination"),
        ];
        
        // Brain Stem
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.6, 4, 16), matBrain.clone());
        stem.position.set(0, -3, 0); stem.rotation.x = 0.2;
        stem.userData = { name: "Brain Stem", desc: "Basic Life Functions" };
        parts.push(stem);
        parts.forEach(p => brainGroup.add(p));
        scene.add(brainGroup);

        // --- DATA PARTICLE SYSTEM (Instanced Cubes) ---
        const PARTICLE_COUNT = 400;
        const dummy = new THREE.Object3D();
        const pGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
        const pMat = new THREE.MeshBasicMaterial({ color: 0x222222 }); // Dark Grey Bits
        const particleMesh = new THREE.InstancedMesh(pGeo, pMat, PARTICLE_COUNT);
        particleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        brainGroup.add(particleMesh); // Add to group so they rotate with brain

        const particles = [];
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            particles.push({
                pos: new THREE.Vector3(),
                target: new THREE.Vector3(),
                state: 0, 
                speed: 0.05 + Math.random() * 0.05,
                phaseOffset: Math.random() * Math.PI * 2
            });
            respawnParticle(particles[i]);
        }

        function respawnParticle(p) {
            // Random source: Eyes (Front), Ears (Sides), Stem (Bottom)
            const r = Math.random();
            if(r < 0.33) {
                // Eyes (Front Z)
                p.pos.set((Math.random()-0.5)*2, 0, 6);
            } else if (r < 0.66) {
                // Ears (Side X)
                p.pos.set(r < 0.5 ? 6 : -6, (Math.random()-0.5)*2, 0);
            } else {
                // Stem (Bottom Y)
                p.pos.set(0, -6, (Math.random()-0.5)*2);
            }
            p.state = 0; // Ingest
            p.target.set(0, -1, 0); // Bottom of stream
        }

        function updateParticles() {
            const time = Date.now() * 0.001;
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const p = particles[i];

                if(p.state === 0) { 
                    // INGEST: Fly to center
                    const dir = new THREE.Vector3().subVectors(p.target, p.pos);
                    if(dir.length() < 0.5) {
                        p.state = 1; // Enter stream
                    } else {
                        dir.normalize().multiplyScalar(p.speed * 3); // Fast ingest
                        p.pos.add(dir);
                    }
                } 
                else if (p.state === 1) {
                    // STREAM: Spiral Up
                    // Radius shrinks as it goes up
                    p.pos.y += p.speed;
                    const radius = 0.5 * (1 - (p.pos.y + 1)/3); // Taper
                    p.pos.x = Math.cos(time * 5 + p.phaseOffset) * radius;
                    p.pos.z = Math.sin(time * 5 + p.phaseOffset) * radius;

                    if(p.pos.y > 1.5) {
                        p.state = 2; // Spread
                        // Pick random target inside brain volume
                        const angle = Math.random() * Math.PI * 2;
                        const r = 2 + Math.random();
                        p.target.set(
                            Math.cos(angle) * r,
                            (Math.random()-0.5) * 2,
                            Math.sin(angle) * r
                        );
                    }
                }
                else if (p.state === 2) {
                    // SPREAD: Move to random target
                    const dir = new THREE.Vector3().subVectors(p.target, p.pos);
                    p.pos.add(dir.multiplyScalar(0.05));
                    
                    if(dir.length() < 0.1 || Math.random() < 0.01) {
                        p.state = 3; // Vacuum
                    }
                }
                else if (p.state === 3) {
                    // VACUUM: Suck back to center
                    const center = new THREE.Vector3(0,0,0);
                    const dir = new THREE.Vector3().subVectors(center, p.pos);
                    p.pos.add(dir.multiplyScalar(0.05));
                    
                    if(dir.length() < 0.5) {
                        // Loop experience (Back to Stream) or Respawn (New Input)
                        p.state = 1; 
                        p.pos.set(0, -1, 0);
                        if(Math.random() < 0.1) respawnParticle(p);
                    }
                }

                // Apply to mesh
                dummy.position.copy(p.pos);
                // Rotate bits randomly
                dummy.rotation.set(time+i, time+i, time); 
                dummy.updateMatrix();
                particleMesh.setMatrixAt(i, dummy.matrix);
            }
            particleMesh.instanceMatrix.needsUpdate = true;
        }

        // Interaction Logic (Tooltip)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('brain-tooltip');
        let hoveredObj = null;

        document.getElementById('container-brain').addEventListener('mousemove', (e) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(brainGroup.children);
            if (intersects.length > 0 && intersects[0].object.geometry.type !== 'BoxGeometry') {
                const obj = intersects[0].object;
                if (hoveredObj !== obj) {
                    if (hoveredObj) hoveredObj.material = matBrain;
                    hoveredObj = obj;
                    hoveredObj.material = matHighlight;
                    document.getElementById('bt-title').innerText = hoveredObj.userData.name;
                    document.getElementById('bt-desc').innerText = hoveredObj.userData.desc;
                    tooltip.style.display = 'block';
                }
            } else {
                if (hoveredObj) { hoveredObj.material = matBrain; hoveredObj = null; tooltip.style.display = 'none'; }
            }
        });

        // Animation Loop
        const animate = () => {
            requestAnimationFrame(animate);
            updateParticles();

            // Group Rotation
            brainGroup.rotation.y = window.scrollY * 0.002;
            brainGroup.rotation.x = Math.sin(window.scrollY * 0.001) * 0.1;
            
            if(controls) controls.update();
            renderer.render(scene, camera);
        };
        animate();
    })();

</script>

</body>
</html>
